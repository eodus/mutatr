% zip -r paper.zip *.pdf *.tex *.bib _include
% zip supplemental.zip *.txt *.r


% SET_DEFAULTS
%   GG-WIDTH: 4  GG-HEIGHT: 4  COL: 2
%   TEX-WIDTH: 0.5\textwidth
%   FILETYPE: png  DPI: 300
%   CACHE: TRUE
%   INLINE: FALSE
% 

% END

\documentclass[oneside]{article}
\usepackage{fullpage}
\usepackage[pdftex]{graphicx}
\DeclareGraphicsExtensions{.png,.pdf}
\graphicspath{{_include/}}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage[format=plain,font=small]{caption}
\usepackage[small]{titlesec}
\usepackage[round,sectionbib]{natbib}
\bibliographystyle{plainnat}
\renewcommand\rmdefault{bch}
\linespread{1.07} 

\title{Mutable objects: does R need another object system?}
\author{Hadley Wickham}
\date{\today}

\raggedbottom

\begin{document}
\maketitle 

This paper motivates why R needs yet another object system and introduces a new package that implements it, \verb|mutator|.

Motivation.  Why does R need another object system?  Because S3 and S4 are not mutable.  What is wrong with the existing mutable object systems?

Why is a prototype based system a good choice?

Inspired by javascript and IO.  


\section{Paradigms}
\label{sec:paradigms}

\citep{roy:2004,van-roy:2009}

Mutable (pass-by-value) vs. immutable (pass-by-reference)

Generic functions (function based OO) vs Message passing
(class based OO)

Advantages and disadvantages

Mutable	Immutable
Required by many of most efficient algorithms	Hard to derive computational complexity
Simplifies dependence between components	Must “thread” state
Concurrency hard	Concurrency easy
Hard to reason about	Compilers can make  very efficient

\begin{itemize}
  \item S3/S4: immutable + generic functions
  \item R.oo : mutable + generic functions
  \item OOP: mutable + message passing
  \item Proto: mutable + message passing
  \item mutatr: mutable + message passing
\end{itemize}

\section{Prototype}
\label{sec:prototype}

Generalisation of class-based oo (like Java) that removes the distinction between classes and instances.
Single dispatch, but often implement multiple (& dynamic) inheritance
Notable languages: Javascript, Io

\section{Comparison to existing methods}
\label{sec:existing}

\begin{itemize}
  \item Clean separation of object methods and base functions.  You can continue to rely on R's lexical scoping, using object scoping as necessary with an explicit reference to {\tt self}.  Much like javascript - heavy use of closures (with lexical scope), but still have object inheritance.  This means it's possible to define functions and variables that are private to a function, enclosed in lexical scope (example.)

  \item No extra function parameters.  Passes self through parent environment so does not require additional function parameters. 

  \item Rich behaviour, including introspection, based on io.

  \item Mutable, multiple inheritance  (depth-first search of inheritance graph).
\end{itemize}

self\$method() needs to have object scoping, not lexical scoping.
That is, rather than looking up based on environment at time function was defined, look it up based on current object.

\section{Programming strategies}
\label{sec:strategies}

Pointers to existing literature.

Method chaining, a la jquery, protovis.

\section{Case studies}
\label{sec:case_studies}

Can simplify code which requires coordinating data from multiple locations: scale code in ggplot2

Complex simulations: e.g. card counting in black jack

When there really is one true underlying object: GUIs and interactive graphics.

Working on a mutatr wrapper of gwidgets.  Makes it much easier to deal with containment.  Hierarchy of code reflects 

\begin{itemize}
  \item don't have to worry about polluting global namespace
  \item hierarchy of object names exactly matches gui hierarchy
  \item indenting matches gui hierarchy
\end{itemize}


\section{Conclusions}
\label{sec:conclusions}

S3/S4 don’t fulfil every need, and it’s fun to experiment with alternative paradigms.

Prototype-based OO is an interesting idea that the distinction between inheritance and instantiation.

We can actually implement it in R, with different scoping rules.  Has been a great learning experience.

% bibtool -x overplotting.aux > references.bib
\bibliography{references}
\end{document}
